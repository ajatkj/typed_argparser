import sys
from argparse import ArgumentError as DefaultArgumentError
from argparse import Namespace
from copy import deepcopy
from functools import wraps
from inspect import _empty, signature
from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Set, Union, cast

from typing_extensions import get_type_hints

import typed_argparser.fields as fields

from .config import ArgumentConfig
from .constants import (
    ONE_OR_MORE,
    OPTIONAL,
    SUBPARSER_TITLE,
    SUPPRESS,
    ZERO_OR_MORE,
    ActionsEnum,
    ArgumentGroupRegistryType,
    ArgumentRegistryType,
    Empty,
    GroupTypeEnum,
)
from .exceptions import ArgumentError, ValidationError
from .groups import ArgumentGroup, _ArgumentGroup, arggroup
from .libs import ArgumentParser as ArgumentParser
from .libs import BooleanOptionalAction
from .types import _PathType, get_types
from .utils import AnnotationType, qualified_name, sort_groups

if TYPE_CHECKING:  # pragma: no cover
    from argparse import ArgumentParser as DefaultArgumentParser
    from argparse import _ArgumentGroup as DefaultArgumentGroup
    from argparse import _MutuallyExclusiveGroup as DefaultMutuallyExclusiveGroup

# Internal keys
_PROGRAM = "__program__"
_DESCRIPTION = "__description__"
_GROUP_DESCRIPTION = "__group_description__"
_EPILOG = "__epilog__"
_USAGE = "__usage__"
_VERSION = "__version__"
_HIDE_TITLE = "__hide_title__"
_EXCLUSIVE = "__exclusive__"
_REQUIRED = "__required__"


class ArgumentClass:
    """
    Main class for parsing Command Line Interface (CLI) arguments.

    This class serves as a base for defining CLI argument structures. Subclasses inherit this class to define
    CLI arguments and subcommands as class variables.

    Example Usage:
    ```
    class CLI(ArgumentClass):
        opt1: str = argfield(help="Opt1 is required and is a string")
        opt2: Optional[int] = argfield(help="Opt2 is an optional integer with an autogenerated long option --opt2")
    ```

    The `__init__` method of this class accepts an optional `ArgumentConfig` object for CLI configuration.
    Other arguments of the `__init__` method are for internal use only and are subject to change in future updates.

    This class exposes several public APIs:
    - `parse()`: Parses the CLI arguments from script arguments. This method is only applicable for the parent ArgumentClass
                 instance.
    - `execute()`: A decorator that allows execution of functions directly based on parsed arguments.
    - `print_help()`: Prints the help message and exits. This can be used to print help messages for commands as well.

    For detailed usage examples and available functionalities, refer to the class documentation and its methods.

    """

    if TYPE_CHECKING:  # pragma: no cover
        __program__: Optional[str]
        __description__: Optional[str]
        __epilog__: Optional[str]
        __usage__: Optional[str]
        __version__: Optional[str]

    help = fields.argfield("--help", help="show this help message and exit", default=SUPPRESS)
    version = fields.argfield("--version", help="show version and exit", default=SUPPRESS)

    def __init__(
        self,
        config: ArgumentConfig = ArgumentConfig(),
        _parser: Optional[ArgumentParser] = None,
        _subcommand_prefix: Optional[str] = None,
        _parent: Optional["ArgumentClass"] = None,
    ) -> None:
        master_class = type(self).mro()[0]
        self._meta_fields = ["help", "version"]
        self.__program__ = getattr(self.__class__, _PROGRAM, self.__class__.__name__.lower())
        self.__description__ = (
            getattr(self.__class__, _DESCRIPTION, None) if _DESCRIPTION in master_class.__dict__ else None
        )
        self.__epilog__ = getattr(self.__class__, _EPILOG, None) if _EPILOG in master_class.__dict__ else None
        self.__usage__ = getattr(self.__class__, _USAGE, None) if _USAGE in master_class.__dict__ else None
        self.__version__ = getattr(self.__class__, _VERSION, None) if _VERSION in master_class.__dict__ else None
        self._fields: Dict[str, fields.ArgumentField] = {}
        self._annotations: Dict[str, AnnotationType] = {}
        self._arg_registry: ArgumentRegistryType = {"_OPTION_FIELDS": [], "_POSITIONAL_FIELDS": [], "_COMMAND_FIELDS": []}
        self._arg_group_registry: Dict[str, ArgumentGroupRegistryType] = {}
        self._subparser_registry: Dict[str, "ArgumentClass"] = {}
        self._raw_annotations = get_type_hints(type(self), include_extras=True)
        self._is_parsed = False
        self._config = config
        self.extra_args: Optional[List[str]] = None
        if _parser:
            self._parser = _parser
            self._subcommand_prefix = _subcommand_prefix
            self._is_subcommand = True
            self._parent = _parent
        else:
            self._parser = ArgumentParser(
                prog=self.__program__,
                description=self.__doc__ or self.__description__,
                epilog=self.__epilog__,
            )
            self._subcommand_prefix = None
            self._is_subcommand = False
            self._parent = None
        for field in self._meta_fields:
            setattr(self, field, deepcopy(getattr(self.__class__, field), None))
        self._add_group_attribute()
        self._update_field_annotations()
        self._update_argfields()
        self._add_groups_to_parser()
        self._add_args_to_parser()
        self._add_parser_to_subparser()
        self._update_parser()
        self._validate_multi_command_mode()
        self._parser.set_custom_argument_groups(self._arg_group_registry)
        self._parser.set_usage(self._update_usage())
        self._parser.set_config(self._config)

    def _update_usage(self) -> Optional[str]:
        # Updating usage after we have all the information for all arguments
        if usage := getattr(self, _USAGE, None):
            if TYPE_CHECKING:  # pragma: no cover
                assert isinstance(usage, str)
            return usage

        if self._config.compact_usage:
            opt_len = len(self._arg_registry["_OPTION_FIELDS"])
            pos_len = len(self._arg_registry["_POSITIONAL_FIELDS"])
            cmd_len = len(self._arg_registry["_COMMAND_FIELDS"])
            usage_string = "%(prog)s"
            options = ""
            if opt_len > 0:
                options += f" [{self._config.option_metavar}] ..." if opt_len > 1 else f" [{self._config.option_metavar}]"
            if pos_len > 0:
                for pos in self._arg_registry["_POSITIONAL_FIELDS"]:
                    if pos.nargs == OPTIONAL:
                        options += " [{}]".format(pos.metavar)
                    elif pos.nargs == ONE_OR_MORE:
                        options += " {} [{} ...]".format(pos.metavar, pos.metavar)
                    elif pos.nargs == ZERO_OR_MORE:
                        options += " [{} ...]".format(pos.metavar)
                    elif isinstance(pos.nargs, int):
                        formats = ["{}".format(pos.metavar) for _ in range(pos.nargs)]
                        options += " " + " ".join(formats)
                    else:
                        if pos.metavar:
                            metavar = pos.metavar if isinstance(pos.metavar, str) else " ".join(list(pos.metavar))
                        else:  # pragma: no cover
                            metavar = ""
                        options += " " + metavar
            if cmd_len > 0:
                options += f" {self._config.command_metavar or 'command'}"
            return usage_string + options

        return None

    def _update_parser(self) -> None:
        # Update the parser object to divide _SubparserAction group into multiple subgroups based on groups
        # defined here since argparse doesn't allow multiple subparsers
        # This allows user to define groups of commands as well like git --help.
        # Remove default groups to avoid conflict with existing groups added by ArgumentParser
        self._parser._remove_default_groups()
        has_commands = list(
            filter(lambda item: item["group_type"] == GroupTypeEnum.COMMAND, self._arg_group_registry.values())
        )
        if not has_commands:
            return
        subparser_action_group = next(
            filter(lambda item: item.title == SUBPARSER_TITLE, self._parser._action_groups), None
        )
        subcommand_groups = dict(
            filter(lambda item: item[1]["group_type"] == GroupTypeEnum.COMMAND, self._arg_group_registry.items())
        )
        if TYPE_CHECKING:  # pragma: no cover
            assert isinstance(subparser_action_group, _ArgumentGroup)
        updated_group_actions = []
        for group_name, subcommand_group in subcommand_groups.items():
            subcommands = list(map(lambda item: item._name, subcommand_group["fields"]))
            group_action = deepcopy(subparser_action_group._group_actions[0])
            new_choices = dict(filter(lambda item: item[0] in subcommands, dict(group_action.choices).items()))
            new_choices_actions = list(
                filter(lambda item: item.metavar.split(" (")[0] in subcommands, group_action._choices_actions)
            )
            group_action.choices = new_choices
            group_action._choices_actions = new_choices_actions
            setattr(group_action, "group", group_name)
            updated_group_actions.append(group_action)
        for ag in self._parser._action_groups:
            if ag.title == SUBPARSER_TITLE:
                ag._group_actions = updated_group_actions

    def _add_group_attribute(self) -> None:
        # This method loops through all inherited classes and adds group attribute to
        # all fields that belong to ArgumentGroup class.
        for cls_ in self.__class__.mro()[1:]:
            # Stop going further when you reach ArgumentClass
            if isinstance(cls_, ArgumentClass):  # pragma: no cover
                break
            # We can use annotations here since we only want the name of the fields
            # and not their types
            annotations = getattr(cls_, "__annotations__", {})
            for name in annotations.keys():
                if name.startswith("__"):  # pragma: no cover
                    continue
                field = getattr(cls_, name, None)
                if field is None and not isinstance(field, fields.ArgumentField):  # pragma: no cover
                    continue
                if issubclass(cls_, ArgumentGroup):
                    field._group = arggroup(
                        cls_.__title__,
                        description=getattr(cls_, _GROUP_DESCRIPTION, None),
                        hide_title=getattr(cls_, _HIDE_TITLE, False),
                        mutually_exclusive=getattr(cls_, _EXCLUSIVE, False),
                        required=getattr(cls_, _REQUIRED, False),
                    )

    def _update_field_annotations(self) -> None:
        field_annotations: Dict[str, AnnotationType] = {}
        # is_optional = False

        for name, annotation in self._raw_annotations.items():
            if name.startswith("__"):
                continue
            field = getattr(self, name, None)
            if field is None or not isinstance(field, fields.ArgumentField):
                raise ArgumentError("field is not initialized or of invalid type.", field=field)
            annotation_type = get_types(annotation)
            # TODO: This is not working for nested classes. Need to fix
            # if annotation_type["optional"] is True:
            #     is_optional = True
            # else:
            #     if is_optional is True:
            #         raise ArgumentError(f"'{name}' - cannot have optional fields before required fields")
            field_annotations[name] = annotation_type

        if self._config.add_help:
            field_annotations["help"] = {"origin": None, "args": None, "value": None, "optional": None}

        if hasattr(self, _VERSION) and getattr(self, _VERSION, None):
            field_annotations["version"] = {"origin": None, "args": None, "value": None, "optional": None}

        self._annotations = field_annotations

    def _validate_field_dest(self, field: fields.ArgumentField) -> None:
        if TYPE_CHECKING:  # pragma: no cover
            assert isinstance(field._original_name, str)
        if field.dest and field._original_name.startswith("_"):
            dest_field = getattr(self, field.dest, None)
            if dest_field is None:
                raise ArgumentError(f"destination field '{field.dest}' must be a valid argfield", field=field)

            if not dest_field.is_list() and not dest_field.is_tuple():
                raise ArgumentError(f"destination field '{dest_field._name}' must be a list or a tuple", field=field)

            if dest_field.const is None:
                raise ArgumentError(f"destination field '{dest_field._name}' must have a 'const' property", field=field)

    def _update_field_dest(self) -> None:
        # Store multiple arguments to same list (destination)
        # All validations are done at this point, hence we are just casting directly to keep mypy happy
        for name, field in self._fields.items():
            if name.startswith("_"):
                self._validate_field_dest(field)
                dest_field = cast(fields.ArgumentField, getattr(self, cast(str, field.dest), None))
                dest_field._action = ActionsEnum.APPEND_CONST
                dest_field.nargs = None

    def _update_argfields(self) -> None:
        # Evaluate and validate all properties of argument fields.
        argfields: Dict[str, fields.ArgumentField] = {}
        shortops: Set[str] = {"-h"}
        longopts: Set[str] = {"--help"}
        aliases: Set[str] = set()

        # Run through all fields and gather short and long options so that duplicates
        # are not generated
        for name in self._annotations:
            field = getattr(self, name, None)
            if field is None or not isinstance(field, fields.ArgumentField):  # pragma: no cover
                continue
            shortops.update(field._shortopts)
            longopts.update(field._longopts)

        for name, field_annotation in self._annotations.items():
            origin = field_annotation.get("origin", None)
            annotation = field_annotation.get("args", None)
            value = field_annotation.get("value")
            is_optional = field_annotation.get("optional")

            field = getattr(self, name, None)
            if field is None or not isinstance(field, fields.ArgumentField):  # pragma: no cover
                continue

            field._config = self._config
            field._required = not is_optional

            field.eval_name(name)
            field._original_name = name
            field._raw_type = self._raw_annotations.get(name)
            field._type = annotation
            field._origin = origin
            field._choices = value
            field.eval_dest(subcommand_prefix=self._subcommand_prefix)
            field.eval_longopts(longopts)
            field.eval_shortopts(shortops)
            field.eval_default()
            field.eval_const()
            field.eval_nargs()
            field.eval_action()
            field.eval_group()
            field.eval_metavar()
            field.eval_aliases(aliases)
            field.eval_help()
            field.eval_counter()
            self._add_arg_to_group(field)
            self._update_arg_registry(field)
            field._processed = True

            if not field.is_subcommand():
                argfields[name] = field

        self._fields = argfields
        self._update_field_dest()

        # Sort groups based on given sort list
        if self._config.groups_sort_order:
            self._arg_group_registry = sort_groups(self._arg_group_registry, self._config.groups_sort_order)

    def _add_arg_to_group(self, field: fields.ArgumentField) -> None:
        # Add each argument to a group
        field_group = cast(_ArgumentGroup, field._group)
        field_type = GroupTypeEnum.COMMAND if field.is_subcommand() else GroupTypeEnum.FIELD
        if field_group.title in self._arg_group_registry:
            group = self._arg_group_registry[field_group.title]
            group_type = group["group_type"]
            fields = group["fields"]
            fields.append(field)
            if group_type != field_type:
                raise ArgumentError("cannot have mixed groups of commands & fields", field=field)
        else:
            self._arg_group_registry[field_group.title] = {
                "group": field_group,
                "fields": [field],
                "group_type": field_type,
            }

    def _update_arg_registry(self, field: fields.ArgumentField) -> None:
        # Sort each argument into command, positional or option fields
        # This is required for generating compact usage message
        if field._name in self._meta_fields:
            return
        if field.is_subcommand():
            self._arg_registry["_COMMAND_FIELDS"].append(field)
        elif field.is_positional():
            self._arg_registry["_POSITIONAL_FIELDS"].append(field)
        else:
            self._arg_registry["_OPTION_FIELDS"].append(field)

    def _add_parser_to_subparser(self) -> None:
        # Since only 1 subparser is allowed per argument parser, we add one with a fixed title which
        # we can use later to divide commands into groups
        subparser = None
        has_commands = list(
            filter(lambda item: item["group_type"] == GroupTypeEnum.COMMAND, self._arg_group_registry.values())
        )
        if len(has_commands) > 0:
            # Do not change the title
            subparser = self._parser.add_subparsers(title=SUBPARSER_TITLE, metavar=self._config.command_metavar)
        if subparser is None:
            return
        subparser_registry: Dict[str, "ArgumentClass"] = {}
        subcommand_groups = {
            key: value for key, value in self._arg_group_registry.items() if value["group_type"] == GroupTypeEnum.COMMAND
        }
        for group in subcommand_groups.values():
            subcommands = group["fields"]
            for subcommand in subcommands:
                if subcommand._type is None:  # pragma: no cover
                    continue
                subcommand._name = cast(str, subcommand._name)
                subcommand_class = subcommand._type
                parser = subparser.add_parser(
                    subcommand._name,
                    prog=getattr(subcommand_class, _PROGRAM, None),
                    help=subcommand.help,
                    description=subcommand_class.__doc__ or getattr(subcommand_class, _DESCRIPTION, None),
                    epilog=getattr(subcommand_class, _EPILOG, None),
                    aliases=subcommand.aliases,
                )
                prefix = (
                    subcommand._name
                    if self._subcommand_prefix is None
                    else f"{self._subcommand_prefix}__{subcommand._name}"
                )
                subparser_registry[subcommand._name] = subcommand_class(
                    _parser=parser, _subcommand_prefix=prefix, config=self._config, _parent=self
                )

        self._subparser_registry.update(subparser_registry)

    def _add_groups_to_parser(self) -> None:
        # Create argument groups in argparse using "argument" groups defined here.
        # Argument groups are not supported for subparsers (commands) so those are not added here.
        for group_detail in self._arg_group_registry.values():
            group = group_detail["group"]
            group_type = group_detail["group_type"]
            fields = group_detail["fields"]
            if group_type == GroupTypeEnum.FIELD:
                group_parser = self._parser.add_argument_group(title=group.title, description=group.description)
                if group.mutually_exclusive:
                    group_parser = group_parser.add_mutually_exclusive_group(required=group.required)
                group._parser = group_parser
                for field in fields:
                    setattr(field._group, "_parser", group_parser)

    def _add_args_to_parser(self) -> None:
        # Add arguments to argparse's ArgumentParser
        for field in self._fields.values():
            args = []
            kwargs = {
                "type": field._type,
                "default": field.default,
                "help": field.help,
                "metavar": field.metavar,
                "nargs": field.nargs,
                "choices": field._choices,
                "action": field._action,
                "dest": field.dest,
                "required": field._required,
                "const": field.const,
            }
            if field.is_positional():
                args.append(field.dest)
                kwargs.pop("required")
                kwargs.pop("dest")
            else:
                args.extend(field._shortopts)
                args.extend(field._longopts)

            if field._action in [ActionsEnum.APPEND_CONST, ActionsEnum.STORE_CONST]:
                kwargs.pop("type")
                kwargs.pop("nargs")
                kwargs.pop("choices")

            if field._action in [ActionsEnum.COUNT]:
                kwargs.pop("type")
                kwargs.pop("nargs")
                kwargs.pop("metavar")
                kwargs.pop("choices")
                kwargs.pop("const")

            if field._action in [ActionsEnum.STORE_TRUE, ActionsEnum.STORE_FALSE, BooleanOptionalAction]:
                kwargs.pop("nargs")
                kwargs.pop("choices")
                kwargs.pop("metavar")
                kwargs.pop("const")
                kwargs.pop("type")

            if field._action in [ActionsEnum.HELP, ActionsEnum.VERSION]:
                kwargs.pop("type")
                kwargs.pop("nargs")
                kwargs.pop("choices")
                kwargs.pop("metavar")
                kwargs.pop("const")
                kwargs.pop("required")

            if field._action == ActionsEnum.VERSION:
                kwargs["version"] = "%(prog)s {}".format(self.__version__)

            parser = self._get_effective_parser(field)
            if TYPE_CHECKING:  # pragma: no cover
                assert isinstance(parser, DefaultArgumentParser)

            try:
                parser.add_argument(*args, **kwargs)  # type: ignore
            except DefaultArgumentError as exc:  # pragma: no cover
                raise ArgumentError(exc.message, field=field) from None

    def _get_effective_parser(
        self, field: fields.ArgumentField
    ) -> Optional[Union["DefaultArgumentParser", "DefaultArgumentGroup", "DefaultMutuallyExclusiveGroup"]]:
        # Get effective parser for the field.
        # i.e. group parser if it is an argparse group or the main parser
        if field._group and isinstance(field._group, _ArgumentGroup):
            return field._group._parser
        else:  # pragma: no cover
            # This will never happen as each and every field is added to a group
            return self._parser

    def _run_validator(self, value: Any, field: fields.ArgumentField) -> None:
        # Run validator, if available
        # Only arguments in validators init method are inspected and sent
        if field.validator and value:
            try:
                argspec = signature(getattr(field.validator, "__init__", object))
                runtime_args = field.get_annotated_args([item.name for item in argspec.parameters.values()])
                field.validator(value, **runtime_args)
            except ValidationError as exc:
                self._parser.error(f"argument {field.get_field_name()}: {exc.message}")
            except Exception as exc:  # pragma: no cover
                self._parser.error(f"argument {field.get_field_name()}: validation failed {exc.args[0]}")

    def _post_parse_conversion(self, value: Any, field: fields.ArgumentField) -> Any:
        # For data types which are not natively supported by argparse, we do post parse conversion
        # Dict and tuple types are handled here
        if value and field.is_dict():
            if field.is_list() and isinstance(value[0], list):
                value = [{k: v for d in val for k, v in d.items()} for val in value]
            else:
                value = {k: v for d in value for k, v in d.items()}

        if value and field._type and field.is_list() and field.is_tuple():
            new_val = []
            for val in value:
                try:
                    new_val.append(field._type(val))
                except ValueError:
                    self._parser.error(f"invalid tuple [{repr(field._type)}] value '{' '.join(val)}'")
            value = new_val

        if value and field._type and not field.is_list() and field.is_tuple():
            try:
                value = field._type(value)
            except ValueError:
                self._parser.error(f"invalid tuple [{repr(field._type)}] value '{' '.join(value)}'")
        return value

    def _update_class_attr_from_args(self, args: "Namespace") -> Dict[str, Any]:
        # Update argument class attributes from argparse Namespace
        parsed_vals = {}
        for name, field in self._fields.items():
            arg_val = getattr(args, qualified_name(name, qual=self._subcommand_prefix), None)
            arg_val = self._post_parse_conversion(arg_val, field)
            self._run_validator(arg_val, field)
            setattr(self, name, arg_val)
            if arg_val is not None and field.default is None:
                parsed_vals[name] = arg_val
        self._is_parsed = True
        return parsed_vals

    def _merge_namespaces(self, namespaces: List[Namespace]) -> Namespace:
        # Merge list of namespace's into single namespace
        new_ns = Namespace()
        for namespace in namespaces:
            for k, v in namespace.__dict__.items():
                setattr(new_ns, k, v) if not hasattr(new_ns, k) and v is not None else None
        return new_ns

    def parse(self, args: Optional[str] = None) -> None:
        # Parse CLI arguments using arparse's parse_known_arguments method.
        # Additionally, for multi-command mode, parse remaining CLI arguments if
        # the leftover token is one of the commands
        # Allow multiple commands by parsing known args in loop until all args are parsed OR
        # the first arg from "extras" is not a known command
        parsed_args_list = []
        parsed_args_, argv = self._parser.parse_known_args(args=args.split() if args else None)
        parsed_args_list.append(parsed_args_)

        # argparse stops after parsing 1 command
        # We try to parse remaining arguments by checking if the first unparsed token
        # is a known command, if not error and exit
        if self._config.allow_multiple_commands:
            while argv:
                if argv[0] not in self._subparser_registry.keys():
                    break
                else:
                    parsed_args_, argv = self._parser.parse_known_args(args=argv)
                    parsed_args_list.append(parsed_args_)
        if argv and self._config.extra_arguments == "error":
            self._parser.error(f"unrecognized arguments {' '.join(argv)}")  # This will exit the script
        elif argv and self._config.extra_arguments == "allow":
            self.extra_args = argv
        else:
            pass

        parsed_vals = {}
        parsed_args = self._merge_namespaces(parsed_args_list)
        parsed_vals_ = self._update_class_attr_from_args(parsed_args)
        if parsed_vals_:
            parsed_vals.update(parsed_vals_)
        a_ = args.split() if args else sys.argv[1:]
        parsed_vals_ = self._update_class_attr_recursively(parsed_args, a_)
        if parsed_vals_:
            parsed_vals.update(parsed_vals_)
        self.parsed_vals = parsed_vals

    def _is_empty_command_name(self, command_name: str, argv: List[str]) -> bool:
        if len(argv) > 0 and command_name == argv[0]:
            argv.remove(command_name)
            return True
        else:
            return False

    def _update_class_attr_recursively(self, parsed_args: "Namespace", cli_args: List[str]) -> Dict[str, Any]:
        # This method is called recursively to update parsed arguments attributes for all subcommands
        # Also, update parsed_vals dictionary with all values parsed by ArgumentClass including empty commands
        parsed_vals = {}
        for command_name, subparser_instance in self._subparser_registry.items():
            parsed_vals_ = subparser_instance._update_class_attr_from_args(parsed_args)
            if parsed_vals_ or self._is_empty_command_name(command_name, cli_args):
                parsed_vals[command_name] = parsed_vals_
            parsed_vals_ = subparser_instance._update_class_attr_recursively(parsed_args, cli_args)
            if parsed_vals_:
                parsed_vals[command_name].update(parsed_vals_)
            setattr(self, command_name, subparser_instance)
            setattr(subparser_instance, "parsed_vals", parsed_vals)
        return parsed_vals

    def execute(self, *dec_args: Any, immediately: bool = True, open_files: bool = True) -> Callable[..., Any]:
        # Decorator to execute a function when all positional arguments of the function are provided
        # via CLI arguments.
        if self._is_parsed is False:
            raise RuntimeError("arguments need to be parsed before running")
        # if self._is_subcommand is True and command is None:
        # raise RuntimeError("'command' argument must be provided to execute command level function")
        if dec_args and callable(dec_args[0]):
            self.execute()(dec_args[0])
        # Mutable objects (like list) can be used to modify state in inner function
        run_immediately = [immediately]
        if self._subcommand_prefix:
            command = self._subcommand_prefix.replace("__", ".")
        else:
            command = None

        def decorator(func: Callable[..., Any]) -> Union[Callable[..., Any], Any]:
            func_args = []
            func_kwargs = {}
            argspec = signature(func)
            cmd_instance = self
            # If decorated function has any args or kwargs in the function definition
            # We are assuming any argument with "default" value set is keyword argument
            for param, param_type in argspec.parameters.items():
                arg = getattr(cmd_instance, param, Empty)
                # If argument is Empty i.e. not found within ArgumentClass that means its not part of the CLI
                # In that case, if default value is not provided in the run function's definition, raise error
                if arg is Empty:
                    if param_type.default is _empty:
                        raise TypeError(f"unknown function argument '{param}'")
                # If argument is found and is found to be None and is not a keyword argument, set run_immediately to false
                elif arg is None and param_type.default is _empty:
                    run_immediately.pop(0)
                    run_immediately.append(False)
                # If argument is found, fill the positional and keyword function arguments based on the parsed args
                else:
                    # Special case to open any files
                    # arg_ = arg
                    if isinstance(arg, _PathType) and open_files is True:
                        try:
                            arg = arg.open()
                        except (IsADirectoryError, FileNotFoundError) as exc:
                            self._parser.error(f"{exc.filename}: {exc.strerror} [Errno {exc.errno}]")
                        except Exception as exc:  # pragma: no cover
                            self._parser.error(f"{arg.name}: {' '.join([str(e) for e in exc.args])}")
                    if isinstance(arg, ArgumentClass):
                        raise TypeError(f"invalid function argument '{param}', subcommands are not allowed")
                    # If default it empty, it is treated as positional argument
                    if param_type.default is _empty:
                        func_args.append(arg)
                    # If default is provided, it is treated as keyword argument
                    else:
                        func_kwargs[param] = arg

            # If decorated function does not have any args or kwargs in the function definition
            # Run the decorated function only if command was provided in CLI.
            # For ex. git remote should print origin. But git remote add ... should do something else.
            if len(argspec.parameters) == 0:
                if command is None:
                    if len(self.parsed_vals) > 0:
                        run_immediately.pop(0)
                        run_immediately.append(False)
                else:
                    parsed_vals = self._get_top_level_parsed_vals(self)
                    vals = parsed_vals
                    for comm in command.split("."):
                        comm = comm.split("__")[-1]
                        vals = vals.get(comm, None)
                        if vals is None:
                            break
                    if vals != {}:
                        run_immediately.pop(0)
                        run_immediately.append(False)

            @wraps(func)
            def wrapper(*args: Any, **kwargs: Any) -> Any:
                return func(*[*func_args, *list(args)], **{**func_kwargs, **kwargs})

            if run_immediately[0]:
                return wrapper()
            else:
                return wrapper

        return decorator

    def _get_top_level_parsed_vals(self, instance: "ArgumentClass") -> Dict[str, Any]:
        def _(
            instance: Optional["ArgumentClass"], prev_instance: Optional["ArgumentClass"] = None
        ) -> Optional[ArgumentClass]:
            if instance and hasattr(instance, "_parent"):
                return _(instance._parent, prev_instance=instance)
            else:
                return instance or prev_instance

        inst = _(instance)
        if inst is None:
            return {}
        else:
            return inst.parsed_vals

    def _validate_multi_command_mode(self) -> None:
        if self._config.allow_multiple_commands is False:
            return

        all_opts: Dict[str, List[str]] = {}

        duplicates = set()
        for name, subcommand in self._subparser_registry.items():
            for fname, field in subcommand._fields.items():
                if fname not in ["help", "version"]:
                    for opt in field._longopts + field._shortopts:
                        if opt in all_opts:
                            duplicates.add(opt)
                            all_opts[opt].append(name)
                        else:
                            all_opts[opt] = [name]

        if duplicates:
            for opt in sorted(duplicates):
                raise ArgumentError(f"'{opt}' is duplicated in subcommand {', '.join(all_opts[opt])}")

    def print_help(self) -> None:
        self._parser.print_help()

    def __repr__(self) -> str:
        if self._is_parsed:
            class_name = "Parsed{}".format(self.__class__.__name__)
        else:
            class_name = "Unparsed{}".format(self.__class__.__name__)
        fields_str = ", ".join(
            f"{name}={getattr(self, name)}" for name in self._fields.keys() if name not in self._meta_fields
        )
        for subcommand_class in self._subparser_registry.values():
            subcommand_fields = repr(subcommand_class)
            prefix = str(
                subcommand_class._subcommand_prefix.split("__")[-1] if subcommand_class._subcommand_prefix else ""
            )
            if fields_str == "":
                fields_str = prefix + "=" + subcommand_fields
            else:
                fields_str += ", " + prefix + "=" + subcommand_fields
        return f"{class_name}({fields_str})"
